\begin{titlepage}
  \begin{center}

  {\Huge AXIS\_1553\_ENCODER}

  \vspace{25mm}

  \includegraphics[width=0.90\textwidth,height=\textheight,keepaspectratio]{img/AFRL.png}

  \vspace{25mm}

  \today

  \vspace{15mm}

  {\Large Jay Convertino}

  \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Usage}

\subsection{Introduction}

\par
AXIS 1553 Encoder is a core for taking AXIS data and encoding for output to the PMOD1553 device. The output
is a TTL differential signal. Meaning when diff[0] is 1 diff[1] is 0. This core also includes a diff enable
which allows for mux switching to the transmit (encoder) when active.

\subsection{Dependencies}

\par
The following are the dependencies of the cores.

\begin{itemize}
  \item fusesoc 2.X
  \item iverilog (simulation)
  \item cocotb (simulation)
\end{itemize}

\input{src/fusesoc/depend_fusesoc_info.tex}

\subsection{In a Project}
\par
Connect the device to your AXIS bus. TUSER is used to set various options such as command/data packet mode.

\par
TDATA input should contain the 16 bit data payload. TUSER is a 8 bit command register
that takes a description what type of data it is (command or data) and other options
described below.

TUSER = {TYY,NA,D,I,P} (7 downto 0)
\begin{itemize}
\item TYY = TYPE OF DATA
  \begin{itemize}
    \item 000 N/A
    \item 001 REG (NOT IMPLEMENTED)
    \item 010 DATA
    \item 100 CMD/STATUS
  \end{itemize}
  \item NA = RESERVED FOR FUTURE USE.
  \item D = DELAY ENABLED
  \begin{itemize}
    \item 1 = 4 us delay enabled.
    \item 0 = no delay between transmissions.
  \end{itemize}
  \item I = INVERT DATA
  \begin{itemize}
    \item 1 = Invert data.
    \item 0 = Normal data.
  \end{itemize}
  \item P = PARITY
  \begin{itemize}
    \item 1 = ODD
    \item 0 = EVEN
  \end{itemize}
\end{itemize}

\section{Architecture}
\par
This core is made up of a single module.
\begin{itemize}
  \item \textbf{axis\_1553\_encoder} Interface AXIS to PMOD1553 device (see core for documentation).
\end{itemize}

\subsection{Encoding Method}
\par
This core has 4 always blocks that are sensitive to the positive clock edge. They are

\begin{itemize}
\item \textbf{pause counter} Inserts delays between transmits to comply with 4us spacing.
\item \textbf{axis data input} Deals with AXIS bus input data to the core based on its current state.
\item \textbf{data processing} In charge of the state machine and processing of input data to 1553 non-differential bitstream.
\item \textbf{differential data output} Output processed data from a non-differential bitstream into a differential one.
\end{itemize}

\par
Pause counter simply gets reset at each transmit state to its initial value. Then once it is out of the transmit state it starts its countdown.
The data processing block checks the pause counter, if it is not 0 we will not transition to the transmit state.

\par
AXIS data input does exactly as it says. Take input data in the data capture state and register it. All other states simply ignore the input data.

\par
Data processing block does most of the work. It is in charge of the state machine state and generating the 1553 non-differential bitstream. Essentially
the state machine does the following:
\begin{enumerate}
\item Startup in error state, which does to the default handler that puts it into data capture.
\item Wait for data input from the AXIS streaming input, once valid data is input. Then go to the data invert state.
\item Check the TUSER command if a data invert is necessary. Always go to the parity generation state.
\item Generate parity bit based upon the input data using xor method. Then move on to process state.
\item In process state take the TUSER and TDATA input and process it into register. This register will contain a non-differential 1553 bitstream.
  \begin{itemize}
  \item Check if pause check is enabled, if it isn't skip it.
  \item Based on TUSER insert the needed sync pulse of command or data. 0 is inserted if a invalid selection is made.
  \item Check parity option for odd or even and insert parity bit based upon selection and generated parity bit.
  \item Generate machester data using XOR method, this is done with a synthetic clock xor with the input data over the number of samples needed. The sythetic clock is contained in the register used for the result.
  \end{itemize}
\item Check for pause (if it wasn't skipped) when counter is 0, move to transmit state.
\item In transmit state wait for differential data output to process all of the register data. Once all conditions are meet, move to the data capture state to wait for more input data to encode.
\end{enumerate}

\par
Differential data output waits for the transmit state, once it is reached the core will begin outputing the registered data generated by data processing in the process state. It will output a TTL
differential version of the data and keep enable diff high so a mux can be switched for transmit mode. Once the data, and by extension counters, are exhausted the block will wait for the next time
transmit state is reached.

\section{Building}

\par
The AXIS 1553 Encoder is written in Verilog 2001. It should synthesize in any modern FPGA software. The core comes as a fusesoc packaged core and can be included in any other core. Be sure to make sure you have meet the dependencies listed in the previous section. Linting is performed by verible using the lint target.

\subsection{fusesoc}
\par
Fusesoc is a system for building FPGA software without relying on the internal project management of the tool. Avoiding vendor lock in to Vivado or Quartus.
These cores, when included in a project, can be easily integrated and targets created based upon the end developer needs. The core by itself is not a part of
a system and should be integrated into a fusesoc based system. Simulations are setup to use fusesoc and are a part of its targets.

\subsection{Source Files}

\input{src/fusesoc/files_fusesoc_info.tex}

\subsection{Targets}

\input{src/fusesoc/targets_fusesoc_info.tex}de

\subsection{Directory Guide}

\par
Below highlights important folders from the root of the directory.

\begin{enumerate}
  \item \textbf{docs} Contains all documentation related to this project.
    \begin{itemize}
      \item \textbf{manual} Contains user manual and github page that are generated from the latex sources.
    \end{itemize}
  \item \textbf{src} Contains source files for the core
  \item \textbf{tb} Contains test bench files for iverilog and cocotb
    \begin{itemize}
      \item \textbf{cocotb} testbench files
    \end{itemize}
\end{enumerate}

\newpage

\section{Simulation}
\par
There are a few different simulations that can be run for this core.

\subsection{iverilog}
\par
iverilog is used for simple test benches for quick verification, visually, of the core.

\subsection{cocotb}
\par
To use the cocotb tests you must install the following python libraries.
\begin{lstlisting}[language=bash]
  $ pip install cocotb
  $ pip install cocotbext-axi
  $ pip install cocotbext-mil_std_1553
\end{lstlisting}

Then you must use the cocotb sim target. The targets above can be run with various bus and fifo parameters.

\begin{lstlisting}[language=bash]
  $ fusesoc run --target sim_cocotb AFRL:device_converter:axis_1553_encoder:1.0.0
\end{lstlisting}


\newpage

\section{Module Documentation} \label{Module Documentation}

\begin{itemize}
\item \textbf{axis\_1553\_encoder} Interfaces AXIS to the PMOD1553.\\
\end{itemize}
The next sections document the module in great detail.

